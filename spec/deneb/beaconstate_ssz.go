// Code generated by dynamic-ssz. DO NOT EDIT.
// Hash: cbbdbae5e7ea2cace676866cbf2b082f25b945864e23d3995229d63d65600aaf
// Version: v0.0.4 (https://github.com/pk910/dynamic-ssz)
package deneb

import (
	"github.com/attestantio/go-eth2-client/spec/altair"
	"github.com/attestantio/go-eth2-client/spec/capella"
	"github.com/attestantio/go-eth2-client/spec/phase0"
	dynssz "github.com/pk910/dynamic-ssz"
	"github.com/pk910/dynamic-ssz/hasher"
	"github.com/pk910/dynamic-ssz/sszutils"
	go_bitfield "github.com/prysmaticlabs/go-bitfield"
)

var _ = sszutils.ErrListTooBig

func (t *BeaconState) MarshalSSZDyn(ds sszutils.DynamicSpecs, buf []byte) (dst []byte, err error) {
	dst = buf
	fn1 := func(t *phase0.Fork) (err error) { // *phase0.Fork
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn2 := func(t *phase0.BeaconBlockHeader) (err error) { // *phase0.BeaconBlockHeader
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn3 := func(t []phase0.Root) (err error) { // []phase0.Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
		hasLimit, limit, err := ds.ResolveSpecValue("SLOTS_PER_HISTORICAL_ROOT")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 8192
		}
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrListTooBig
		}
		for i := 0; i < vlen; i++ {
			dst = append(dst, t[i][:]...)
		}
		if vlen < int(limit) {
			dst = sszutils.AppendZeroPadding(dst, (int(limit)-vlen)*32)
		}
		return err
	}
	fn4 := func(t []phase0.Root) (err error) { // []phase0.Root:32
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			dst = append(dst, t[i][:]...)
		}
		return err
	}
	fn5 := func(t *phase0.ETH1Data) (err error) { // *phase0.ETH1Data
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn6 := func(t []*phase0.ETH1Data) (err error) { // []*phase0.ETH1Data
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			if err = fn5(t[i]); err != nil {
				return err
			}
		}
		return err
	}
	fn7 := func(t *phase0.Validator) (err error) { // *phase0.Validator
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn8 := func(t []*phase0.Validator) (err error) { // []*phase0.Validator
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			if err = fn7(t[i]); err != nil {
				return err
			}
		}
		return err
	}
	fn9 := func(t []phase0.Gwei) (err error) { // []phase0.Gwei
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			dst = sszutils.MarshalUint64(dst, uint64(t[i]))
		}
		return err
	}
	fn10 := func(t []phase0.Root) (err error) { // []phase0.Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
		hasLimit, limit, err := ds.ResolveSpecValue("EPOCHS_PER_HISTORICAL_VECTOR")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 65536
		}
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrListTooBig
		}
		for i := 0; i < vlen; i++ {
			dst = append(dst, t[i][:]...)
		}
		if vlen < int(limit) {
			dst = sszutils.AppendZeroPadding(dst, (int(limit)-vlen)*32)
		}
		return err
	}
	fn11 := func(t []phase0.Gwei) (err error) { // []phase0.Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
		hasLimit, limit, err := ds.ResolveSpecValue("EPOCHS_PER_SLASHINGS_VECTOR")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 8192
		}
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrListTooBig
		}
		for i := 0; i < vlen; i++ {
			dst = sszutils.MarshalUint64(dst, uint64(t[i]))
		}
		if vlen < int(limit) {
			dst = sszutils.AppendZeroPadding(dst, (int(limit)-vlen)*8)
		}
		return err
	}
	fn12 := func(t []altair.ParticipationFlags) (err error) { // []altair.ParticipationFlags
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			dst = sszutils.MarshalUint8(dst, uint8(t[i]))
		}
		return err
	}
	fn13 := func(t *phase0.Checkpoint) (err error) { // *phase0.Checkpoint
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn14 := func(t []uint64) (err error) { // []uint64
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			dst = sszutils.MarshalUint64(dst, uint64(t[i]))
		}
		return err
	}
	fn15 := func(t *altair.SyncCommittee) (err error) { // *altair.SyncCommittee
		dst, err = t.MarshalSSZDyn(ds, dst)
		return err
	}
	fn16 := func(t *ExecutionPayloadHeader) (err error) { // *deneb.ExecutionPayloadHeader
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn17 := func(t *capella.HistoricalSummary) (err error) { // *capella.HistoricalSummary
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn18 := func(t []*capella.HistoricalSummary) (err error) { // []*capella.HistoricalSummary
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			if err = fn17(t[i]); err != nil {
				return err
			}
		}
		return err
	}
	fn19 := func(t *BeaconState) (err error) { // *deneb.BeaconState
		dstlen := len(dst)
		// Field #0 'GenesisTime'
		dst = sszutils.MarshalUint64(dst, uint64(t.GenesisTime))
		// Field #1 'GenesisValidatorsRoot'
		dst = append(dst, t.GenesisValidatorsRoot[:]...)
		// Field #2 'Slot'
		dst = sszutils.MarshalUint64(dst, uint64(t.Slot))
		// Field #3 'Fork'
		if err = fn1(t.Fork); err != nil {
			return err
		}
		// Field #4 'LatestBlockHeader'
		if err = fn2(t.LatestBlockHeader); err != nil {
			return err
		}
		// Field #5 'BlockRoots'
		if err = fn3(t.BlockRoots); err != nil {
			return err
		}
		// Field #6 'StateRoots'
		if err = fn3(t.StateRoots); err != nil {
			return err
		}
		// Offset #7 'HistoricalRoots'
		offset7 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Field #8 'ETH1Data'
		if err = fn5(t.ETH1Data); err != nil {
			return err
		}
		// Offset #9 'ETH1DataVotes'
		offset9 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Field #10 'ETH1DepositIndex'
		dst = sszutils.MarshalUint64(dst, uint64(t.ETH1DepositIndex))
		// Offset #11 'Validators'
		offset11 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Offset #12 'Balances'
		offset12 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Field #13 'RANDAOMixes'
		if err = fn10(t.RANDAOMixes); err != nil {
			return err
		}
		// Field #14 'Slashings'
		if err = fn11(t.Slashings); err != nil {
			return err
		}
		// Offset #15 'PreviousEpochParticipation'
		offset15 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Offset #16 'CurrentEpochParticipation'
		offset16 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Field #17 'JustificationBits'
		if len(t.JustificationBits) > 1 {
			dst = append(dst, t.JustificationBits[:1]...)
		} else {
			dst = append(dst, t.JustificationBits[:]...)
			if len(t.JustificationBits) < 1 {
				dst = sszutils.AppendZeroPadding(dst, 1-len(t.JustificationBits))
			}
		}
		// Field #18 'PreviousJustifiedCheckpoint'
		if err = fn13(t.PreviousJustifiedCheckpoint); err != nil {
			return err
		}
		// Field #19 'CurrentJustifiedCheckpoint'
		if err = fn13(t.CurrentJustifiedCheckpoint); err != nil {
			return err
		}
		// Field #20 'FinalizedCheckpoint'
		if err = fn13(t.FinalizedCheckpoint); err != nil {
			return err
		}
		// Offset #21 'InactivityScores'
		offset21 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Field #22 'CurrentSyncCommittee'
		if err = fn15(t.CurrentSyncCommittee); err != nil {
			return err
		}
		// Field #23 'NextSyncCommittee'
		if err = fn15(t.NextSyncCommittee); err != nil {
			return err
		}
		// Offset #24 'LatestExecutionPayloadHeader'
		offset24 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Field #25 'NextWithdrawalIndex'
		dst = sszutils.MarshalUint64(dst, uint64(t.NextWithdrawalIndex))
		// Field #26 'NextWithdrawalValidatorIndex'
		dst = sszutils.MarshalUint64(dst, uint64(t.NextWithdrawalValidatorIndex))
		// Offset #27 'HistoricalSummaries'
		offset27 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Dynamic Field #7 'HistoricalRoots'
		sszutils.UpdateOffset(dst[offset7:offset7+4], len(dst)-dstlen)
		if err = fn4(t.HistoricalRoots); err != nil {
			return err
		}
		// Dynamic Field #9 'ETH1DataVotes'
		sszutils.UpdateOffset(dst[offset9:offset9+4], len(dst)-dstlen)
		if err = fn6(t.ETH1DataVotes); err != nil {
			return err
		}
		// Dynamic Field #11 'Validators'
		sszutils.UpdateOffset(dst[offset11:offset11+4], len(dst)-dstlen)
		if err = fn8(t.Validators); err != nil {
			return err
		}
		// Dynamic Field #12 'Balances'
		sszutils.UpdateOffset(dst[offset12:offset12+4], len(dst)-dstlen)
		if err = fn9(t.Balances); err != nil {
			return err
		}
		// Dynamic Field #15 'PreviousEpochParticipation'
		sszutils.UpdateOffset(dst[offset15:offset15+4], len(dst)-dstlen)
		if err = fn12(t.PreviousEpochParticipation); err != nil {
			return err
		}
		// Dynamic Field #16 'CurrentEpochParticipation'
		sszutils.UpdateOffset(dst[offset16:offset16+4], len(dst)-dstlen)
		if err = fn12(t.CurrentEpochParticipation); err != nil {
			return err
		}
		// Dynamic Field #21 'InactivityScores'
		sszutils.UpdateOffset(dst[offset21:offset21+4], len(dst)-dstlen)
		if err = fn14(t.InactivityScores); err != nil {
			return err
		}
		// Dynamic Field #24 'LatestExecutionPayloadHeader'
		sszutils.UpdateOffset(dst[offset24:offset24+4], len(dst)-dstlen)
		if err = fn16(t.LatestExecutionPayloadHeader); err != nil {
			return err
		}
		// Dynamic Field #27 'HistoricalSummaries'
		sszutils.UpdateOffset(dst[offset27:offset27+4], len(dst)-dstlen)
		if err = fn18(t.HistoricalSummaries); err != nil {
			return err
		}
		return err
	}
	err = fn19(t)
	return dst, err
}
func (t *BeaconState) MarshalSSZ() ([]byte, error) {
	return dynssz.GetGlobalDynSsz().MarshalSSZ(t)
}
func (t *BeaconState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	return t.MarshalSSZDyn(dynssz.GetGlobalDynSsz(), buf)
}

func (t *BeaconState) SizeSSZDyn(ds sszutils.DynamicSpecs) (size int) {
	sfn1 := func(t []phase0.Root) (size int) { // []phase0.Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
		hasLimit, limit, _ := ds.ResolveSpecValue("SLOTS_PER_HISTORICAL_ROOT")
		if !hasLimit {
			limit = 8192
		}
		size += int(limit) * 32
		return size
	}
	sfn2 := func(t []phase0.Root) (size int) { // []phase0.Root:32
		size += len(t) * 32
		return size
	}
	sfn3 := func(t []*phase0.ETH1Data) (size int) { // []*phase0.ETH1Data
		size += len(t) * 72
		return size
	}
	sfn4 := func(t []*phase0.Validator) (size int) { // []*phase0.Validator
		size += len(t) * 121
		return size
	}
	sfn5 := func(t []phase0.Gwei) (size int) { // []phase0.Gwei
		size += len(t) * 8
		return size
	}
	sfn6 := func(t []phase0.Root) (size int) { // []phase0.Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
		hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_HISTORICAL_VECTOR")
		if !hasLimit {
			limit = 65536
		}
		size += int(limit) * 32
		return size
	}
	sfn7 := func(t []phase0.Gwei) (size int) { // []phase0.Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
		hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_SLASHINGS_VECTOR")
		if !hasLimit {
			limit = 8192
		}
		size += int(limit) * 8
		return size
	}
	sfn8 := func(t []altair.ParticipationFlags) (size int) { // []altair.ParticipationFlags
		size += len(t) * 1
		return size
	}
	sfn9 := func(t []uint64) (size int) { // []uint64
		size += len(t) * 8
		return size
	}
	sfn10 := func(t *altair.SyncCommittee) (size int) { // *altair.SyncCommittee
		size = t.SizeSSZDyn(ds)
		return size
	}
	sfn11 := func(t *ExecutionPayloadHeader) (size int) { // *ExecutionPayloadHeader
		size = t.SizeSSZ()
		return size
	}
	sfn12 := func(t []*capella.HistoricalSummary) (size int) { // []*capella.HistoricalSummary
		size += len(t) * 64
		return size
	}
	sfn13 := func(t *BeaconState) (size int) { // *BeaconState
		size = 393
		size += sfn1(t.BlockRoots)
		size += sfn1(t.StateRoots)
		size += 4 + sfn2(t.HistoricalRoots)
		size += 4 + sfn3(t.ETH1DataVotes)
		size += 4 + sfn4(t.Validators)
		size += 4 + sfn5(t.Balances)
		size += sfn6(t.RANDAOMixes)
		size += sfn7(t.Slashings)
		size += 4 + sfn8(t.PreviousEpochParticipation)
		size += 4 + sfn8(t.CurrentEpochParticipation)
		size += 4 + sfn9(t.InactivityScores)
		size += sfn10(t.CurrentSyncCommittee)
		size += sfn10(t.NextSyncCommittee)
		size += 4 + sfn11(t.LatestExecutionPayloadHeader)
		size += 4 + sfn12(t.HistoricalSummaries)
		return size
	}
	return sfn13(t)
}
func (t *BeaconState) SizeSSZ() (size int) {
	return t.SizeSSZDyn(dynssz.GetGlobalDynSsz())
}

func (t *BeaconState) UnmarshalSSZDyn(ds sszutils.DynamicSpecs, buf []byte) (err error) {
	sfn1 := func() (size int) { // []phase0.Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
		hasLimit, limit, _ := ds.ResolveSpecValue("SLOTS_PER_HISTORICAL_ROOT")
		if !hasLimit {
			limit = 8192
		}
		size += int(limit) * 32
		return size
	}()
	sfn2 := func() (size int) { // []phase0.Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
		hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_HISTORICAL_VECTOR")
		if !hasLimit {
			limit = 65536
		}
		size += int(limit) * 32
		return size
	}()
	sfn3 := func() (size int) { // []phase0.Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
		hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_SLASHINGS_VECTOR")
		if !hasLimit {
			limit = 8192
		}
		size += int(limit) * 8
		return size
	}()
	sfn4 := func() (size int) { // []phase0.BLSPubKey:512:SYNC_COMMITTEE_SIZE:48
		hasLimit, limit, _ := ds.ResolveSpecValue("SYNC_COMMITTEE_SIZE")
		if !hasLimit {
			limit = 512
		}
		size += int(limit) * 48
		return size
	}()
	sfn5 := func() (size int) { // *altair.SyncCommittee
		size = 48
		size += sfn4
		return size
	}()
	fn1 := func(t *phase0.Fork, buf []byte) (*phase0.Fork, error) { // *phase0.Fork
		var err error
		if t == nil {
			t = new(phase0.Fork)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn2 := func(t *phase0.BeaconBlockHeader, buf []byte) (*phase0.BeaconBlockHeader, error) { // *phase0.BeaconBlockHeader
		var err error
		if t == nil {
			t = new(phase0.BeaconBlockHeader)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn3 := func(t []phase0.Root, buf []byte) ([]phase0.Root, error) { // []phase0.Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
		var err error
		itemsize := 32
		limit := sfn1 / itemsize
		if len(t) < int(limit) {
			t = make([]phase0.Root, int(limit))
		} else {
			t = t[:int(limit)]
		}
		if len(buf) > int(limit)*itemsize {
			return t, sszutils.ErrListTooBig
		}
		for i := 0; i < int(limit); i++ {
			copy(t[i][:], buf[i*itemsize:(i+1)*itemsize])
		}
		return t, err
	}
	fn4 := func(t []phase0.Root, buf []byte) ([]phase0.Root, error) { // []phase0.Root:32
		var err error
		buflen := len(buf)
		itemsize := 32
		itemCount := buflen / itemsize
		if buflen%itemsize != 0 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]phase0.Root, itemCount)
		} else {
			t = t[:itemCount]
		}
		for i := 0; i < itemCount; i++ {
			copy(t[i][:], buf[i*itemsize:(i+1)*itemsize])
		}
		return t, err
	}
	fn5 := func(t *phase0.ETH1Data, buf []byte) (*phase0.ETH1Data, error) { // *phase0.ETH1Data
		var err error
		if t == nil {
			t = new(phase0.ETH1Data)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn6 := func(t []*phase0.ETH1Data, buf []byte) ([]*phase0.ETH1Data, error) { // []*phase0.ETH1Data
		var err error
		buflen := len(buf)
		itemsize := 72
		itemCount := buflen / itemsize
		if buflen%itemsize != 0 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]*phase0.ETH1Data, itemCount)
		} else {
			t = t[:itemCount]
		}
		for i := 0; i < itemCount; i++ {
			if t[i], err = fn5(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
				return t, err
			}
		}
		return t, err
	}
	fn7 := func(t *phase0.Validator, buf []byte) (*phase0.Validator, error) { // *phase0.Validator
		var err error
		if t == nil {
			t = new(phase0.Validator)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn8 := func(t []*phase0.Validator, buf []byte) ([]*phase0.Validator, error) { // []*phase0.Validator
		var err error
		buflen := len(buf)
		itemsize := 121
		itemCount := buflen / itemsize
		if buflen%itemsize != 0 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]*phase0.Validator, itemCount)
		} else {
			t = t[:itemCount]
		}
		for i := 0; i < itemCount; i++ {
			if t[i], err = fn7(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
				return t, err
			}
		}
		return t, err
	}
	fn9 := func(t []phase0.Gwei, buf []byte) ([]phase0.Gwei, error) { // []phase0.Gwei
		var err error
		buflen := len(buf)
		itemsize := 8
		itemCount := buflen / itemsize
		if buflen%itemsize != 0 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]phase0.Gwei, itemCount)
		} else {
			t = t[:itemCount]
		}
		for i := 0; i < itemCount; i++ {
			t[i] = (phase0.Gwei)(sszutils.UnmarshallUint64(buf[i*itemsize : (i+1)*itemsize]))
		}
		return t, err
	}
	fn10 := func(t []phase0.Root, buf []byte) ([]phase0.Root, error) { // []phase0.Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
		var err error
		itemsize := 32
		limit := sfn2 / itemsize
		if len(t) < int(limit) {
			t = make([]phase0.Root, int(limit))
		} else {
			t = t[:int(limit)]
		}
		if len(buf) > int(limit)*itemsize {
			return t, sszutils.ErrListTooBig
		}
		for i := 0; i < int(limit); i++ {
			copy(t[i][:], buf[i*itemsize:(i+1)*itemsize])
		}
		return t, err
	}
	fn11 := func(t []phase0.Gwei, buf []byte) ([]phase0.Gwei, error) { // []phase0.Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
		var err error
		itemsize := 8
		limit := sfn3 / itemsize
		if len(t) < int(limit) {
			t = make([]phase0.Gwei, int(limit))
		} else {
			t = t[:int(limit)]
		}
		if len(buf) > int(limit)*itemsize {
			return t, sszutils.ErrListTooBig
		}
		for i := 0; i < int(limit); i++ {
			t[i] = (phase0.Gwei)(sszutils.UnmarshallUint64(buf[i*itemsize : (i+1)*itemsize]))
		}
		return t, err
	}
	fn12 := func(t []altair.ParticipationFlags, buf []byte) ([]altair.ParticipationFlags, error) { // []altair.ParticipationFlags
		var err error
		buflen := len(buf)
		itemsize := 1
		itemCount := buflen / itemsize
		if buflen%itemsize != 0 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]altair.ParticipationFlags, itemCount)
		} else {
			t = t[:itemCount]
		}
		for i := 0; i < itemCount; i++ {
			t[i] = (altair.ParticipationFlags)(sszutils.UnmarshallUint8(buf[i*itemsize : (i+1)*itemsize]))
		}
		return t, err
	}
	fn13 := func(t *phase0.Checkpoint, buf []byte) (*phase0.Checkpoint, error) { // *phase0.Checkpoint
		var err error
		if t == nil {
			t = new(phase0.Checkpoint)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn14 := func(t []uint64, buf []byte) ([]uint64, error) { // []uint64
		var err error
		buflen := len(buf)
		itemsize := 8
		itemCount := buflen / itemsize
		if buflen%itemsize != 0 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]uint64, itemCount)
		} else {
			t = t[:itemCount]
		}
		for i := 0; i < itemCount; i++ {
			t[i] = (uint64)(sszutils.UnmarshallUint64(buf[i*itemsize : (i+1)*itemsize]))
		}
		return t, err
	}
	fn15 := func(t *altair.SyncCommittee, buf []byte) (*altair.SyncCommittee, error) { // *altair.SyncCommittee
		var err error
		if t == nil {
			t = new(altair.SyncCommittee)
		}
		err = t.UnmarshalSSZDyn(ds, buf)
		return t, err
	}
	fn16 := func(t *ExecutionPayloadHeader, buf []byte) (*ExecutionPayloadHeader, error) { // *ExecutionPayloadHeader
		var err error
		if t == nil {
			t = new(ExecutionPayloadHeader)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn17 := func(t *capella.HistoricalSummary, buf []byte) (*capella.HistoricalSummary, error) { // *capella.HistoricalSummary
		var err error
		if t == nil {
			t = new(capella.HistoricalSummary)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn18 := func(t []*capella.HistoricalSummary, buf []byte) ([]*capella.HistoricalSummary, error) { // []*capella.HistoricalSummary
		var err error
		buflen := len(buf)
		itemsize := 64
		itemCount := buflen / itemsize
		if buflen%itemsize != 0 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]*capella.HistoricalSummary, itemCount)
		} else {
			t = t[:itemCount]
		}
		for i := 0; i < itemCount; i++ {
			if t[i], err = fn17(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
				return t, err
			}
		}
		return t, err
	}
	fn19 := func(t *BeaconState, buf []byte) (*BeaconState, error) { // *BeaconState
		var err error
		if t == nil {
			t = new(BeaconState)
		}
		bufpos := 0
		buflen := len(buf)
		minsize := 429
		if buflen < minsize {
			return t, sszutils.ErrUnexpectedEOF
		}
		// Field #0 'GenesisTime'
		{
			fieldsize := 8
			t.GenesisTime = (uint64)(sszutils.UnmarshallUint64(buf[bufpos : bufpos+fieldsize]))
			bufpos += fieldsize
		}
		// Field #1 'GenesisValidatorsRoot'
		{
			fieldsize := 32
			copy(t.GenesisValidatorsRoot[:], buf[bufpos:bufpos+fieldsize])
			bufpos += fieldsize
		}
		// Field #2 'Slot'
		{
			fieldsize := 8
			t.Slot = (phase0.Slot)(sszutils.UnmarshallUint64(buf[bufpos : bufpos+fieldsize]))
			bufpos += fieldsize
		}
		// Field #3 'Fork'
		{
			fieldsize := 16
			if t.Fork, err = fn1(t.Fork, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #4 'LatestBlockHeader'
		{
			fieldsize := 112
			if t.LatestBlockHeader, err = fn2(t.LatestBlockHeader, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #5 'BlockRoots'
		{
			fieldsize := sfn1
			minsize += fieldsize
			if buflen < minsize {
				return t, sszutils.ErrUnexpectedEOF
			}
			if t.BlockRoots, err = fn3(t.BlockRoots, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #6 'StateRoots'
		{
			fieldsize := sfn1
			minsize += fieldsize
			if buflen < minsize {
				return t, sszutils.ErrUnexpectedEOF
			}
			if t.StateRoots, err = fn3(t.StateRoots, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Offset #7 'HistoricalRoots'
		offset7 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Field #8 'ETH1Data'
		{
			fieldsize := 72
			if t.ETH1Data, err = fn5(t.ETH1Data, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Offset #9 'ETH1DataVotes'
		offset9 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Field #10 'ETH1DepositIndex'
		{
			fieldsize := 8
			t.ETH1DepositIndex = (uint64)(sszutils.UnmarshallUint64(buf[bufpos : bufpos+fieldsize]))
			bufpos += fieldsize
		}
		// Offset #11 'Validators'
		offset11 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Offset #12 'Balances'
		offset12 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Field #13 'RANDAOMixes'
		{
			fieldsize := sfn2
			minsize += fieldsize
			if buflen < minsize {
				return t, sszutils.ErrUnexpectedEOF
			}
			if t.RANDAOMixes, err = fn10(t.RANDAOMixes, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #14 'Slashings'
		{
			fieldsize := sfn3
			minsize += fieldsize
			if buflen < minsize {
				return t, sszutils.ErrUnexpectedEOF
			}
			if t.Slashings, err = fn11(t.Slashings, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Offset #15 'PreviousEpochParticipation'
		offset15 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Offset #16 'CurrentEpochParticipation'
		offset16 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Field #17 'JustificationBits'
		{
			fieldsize := 1
			if len(t.JustificationBits) < len(buf[bufpos:bufpos+fieldsize]) {
				t.JustificationBits = make(go_bitfield.Bitvector4, len(buf[bufpos:bufpos+fieldsize]))
			} else {
				t.JustificationBits = t.JustificationBits[:len(buf[bufpos:bufpos+fieldsize])]
			}
			copy(t.JustificationBits[:], buf[bufpos:bufpos+fieldsize])
			bufpos += fieldsize
		}
		// Field #18 'PreviousJustifiedCheckpoint'
		{
			fieldsize := 40
			if t.PreviousJustifiedCheckpoint, err = fn13(t.PreviousJustifiedCheckpoint, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #19 'CurrentJustifiedCheckpoint'
		{
			fieldsize := 40
			if t.CurrentJustifiedCheckpoint, err = fn13(t.CurrentJustifiedCheckpoint, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #20 'FinalizedCheckpoint'
		{
			fieldsize := 40
			if t.FinalizedCheckpoint, err = fn13(t.FinalizedCheckpoint, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Offset #21 'InactivityScores'
		offset21 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Field #22 'CurrentSyncCommittee'
		{
			fieldsize := sfn5
			minsize += fieldsize
			if buflen < minsize {
				return t, sszutils.ErrUnexpectedEOF
			}
			if t.CurrentSyncCommittee, err = fn15(t.CurrentSyncCommittee, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #23 'NextSyncCommittee'
		{
			fieldsize := sfn5
			minsize += fieldsize
			if buflen < minsize {
				return t, sszutils.ErrUnexpectedEOF
			}
			if t.NextSyncCommittee, err = fn15(t.NextSyncCommittee, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Offset #24 'LatestExecutionPayloadHeader'
		offset24 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Field #25 'NextWithdrawalIndex'
		{
			fieldsize := 8
			t.NextWithdrawalIndex = (capella.WithdrawalIndex)(sszutils.UnmarshallUint64(buf[bufpos : bufpos+fieldsize]))
			bufpos += fieldsize
		}
		// Field #26 'NextWithdrawalValidatorIndex'
		{
			fieldsize := 8
			t.NextWithdrawalValidatorIndex = (phase0.ValidatorIndex)(sszutils.UnmarshallUint64(buf[bufpos : bufpos+fieldsize]))
			bufpos += fieldsize
		}
		// Offset #27 'HistoricalSummaries'
		offset27 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Dynamic Field #7 'HistoricalRoots'
		if offset7 < bufpos || offset9 > buflen || offset9 < offset7 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset7:offset9]
			if t.HistoricalRoots, err = fn4(t.HistoricalRoots, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #9 'ETH1DataVotes'
		if offset9 < bufpos || offset11 > buflen || offset11 < offset9 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset9:offset11]
			if t.ETH1DataVotes, err = fn6(t.ETH1DataVotes, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #11 'Validators'
		if offset11 < bufpos || offset12 > buflen || offset12 < offset11 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset11:offset12]
			if t.Validators, err = fn8(t.Validators, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #12 'Balances'
		if offset12 < bufpos || offset15 > buflen || offset15 < offset12 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset12:offset15]
			if t.Balances, err = fn9(t.Balances, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #15 'PreviousEpochParticipation'
		if offset15 < bufpos || offset16 > buflen || offset16 < offset15 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset15:offset16]
			if t.PreviousEpochParticipation, err = fn12(t.PreviousEpochParticipation, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #16 'CurrentEpochParticipation'
		if offset16 < bufpos || offset21 > buflen || offset21 < offset16 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset16:offset21]
			if t.CurrentEpochParticipation, err = fn12(t.CurrentEpochParticipation, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #21 'InactivityScores'
		if offset21 < bufpos || offset24 > buflen || offset24 < offset21 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset21:offset24]
			if t.InactivityScores, err = fn14(t.InactivityScores, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #24 'LatestExecutionPayloadHeader'
		if offset24 < bufpos || offset27 > buflen || offset27 < offset24 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset24:offset27]
			if t.LatestExecutionPayloadHeader, err = fn16(t.LatestExecutionPayloadHeader, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #27 'HistoricalSummaries'
		if offset27 < bufpos {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset27:]
			if t.HistoricalSummaries, err = fn18(t.HistoricalSummaries, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		return t, err
	}
	_, err = fn19(t, buf)
	return err
}
func (t *BeaconState) UnmarshalSSZ(buf []byte) (err error) {
	return t.UnmarshalSSZDyn(dynssz.GetGlobalDynSsz(), buf)
}

func (t *BeaconState) HashTreeRootWithDyn(ds sszutils.DynamicSpecs, hh sszutils.HashWalker) error {
	fn1 := func(t []phase0.Root) (err error) { // []phase0.Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
		hasLimit, limit, err := ds.ResolveSpecValue("SLOTS_PER_HISTORICAL_ROOT")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 8192
		}
		idx := hh.Index()
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrVectorLength
		}
		for i := 0; i < vlen; i++ {
			hh.PutBytes(t[i][:])
		}
		for i := vlen; i < int(limit); i++ {
			hh.PutUint8(0)
		}
		hh.Merkleize(idx)
		return err
	}
	fn2 := func(t []phase0.Root) (err error) { // []phase0.Root:16777216:HISTORICAL_ROOTS_LIMIT:32
		hasLimit, maxLen, err := ds.ResolveSpecValue("HISTORICAL_ROOTS_LIMIT")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 16777216
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			hh.PutBytes(t[i][:])
		}
		limit := uint64(maxLen)
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn3 := func(t []*phase0.ETH1Data) (err error) { // []*phase0.ETH1Data:2048:EPOCHS_PER_ETH1_VOTING_PERIOD*SLOTS_PER_EPOCH
		hasLimit, maxLen, err := ds.ResolveSpecValue("EPOCHS_PER_ETH1_VOTING_PERIOD*SLOTS_PER_EPOCH")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 2048
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			if err = t[i].HashTreeRootWith(hh); err != nil {
				return err
			}
		}
		limit := uint64(maxLen)
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn4 := func(t []*phase0.Validator) (err error) { // []*phase0.Validator:1099511627776:VALIDATOR_REGISTRY_LIMIT
		hasLimit, maxLen, err := ds.ResolveSpecValue("VALIDATOR_REGISTRY_LIMIT")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 1099511627776
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			if err = t[i].HashTreeRootWith(hh); err != nil {
				return err
			}
		}
		limit := uint64(maxLen)
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn5 := func(t []phase0.Gwei) (err error) { // []phase0.Gwei:1099511627776:VALIDATOR_REGISTRY_LIMIT
		hasLimit, maxLen, err := ds.ResolveSpecValue("VALIDATOR_REGISTRY_LIMIT")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 1099511627776
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			hh.AppendUint64(uint64(t[i]))
		}
		limit := sszutils.CalculateLimit(uint64(maxLen), uint64(vlen), uint64(8))
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn6 := func(t []phase0.Root) (err error) { // []phase0.Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
		hasLimit, limit, err := ds.ResolveSpecValue("EPOCHS_PER_HISTORICAL_VECTOR")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 65536
		}
		idx := hh.Index()
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrVectorLength
		}
		for i := 0; i < vlen; i++ {
			hh.PutBytes(t[i][:])
		}
		for i := vlen; i < int(limit); i++ {
			hh.PutUint8(0)
		}
		hh.Merkleize(idx)
		return err
	}
	fn7 := func(t []phase0.Gwei) (err error) { // []phase0.Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
		hasLimit, limit, err := ds.ResolveSpecValue("EPOCHS_PER_SLASHINGS_VECTOR")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 8192
		}
		idx := hh.Index()
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrVectorLength
		}
		for i := 0; i < vlen; i++ {
			hh.AppendUint64(uint64(t[i]))
		}
		for i := vlen; i < int(limit); i++ {
			hh.PutUint8(0)
		}
		hh.Merkleize(idx)
		return err
	}
	fn8 := func(t []altair.ParticipationFlags) (err error) { // []altair.ParticipationFlags:1099511627776:VALIDATOR_REGISTRY_LIMIT
		hasLimit, maxLen, err := ds.ResolveSpecValue("VALIDATOR_REGISTRY_LIMIT")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 1099511627776
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			hh.AppendUint8(uint8(t[i]))
		}
		limit := sszutils.CalculateLimit(uint64(maxLen), uint64(vlen), uint64(1))
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn9 := func(t []uint64) (err error) { // []uint64:1099511627776:VALIDATOR_REGISTRY_LIMIT
		hasLimit, maxLen, err := ds.ResolveSpecValue("VALIDATOR_REGISTRY_LIMIT")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 1099511627776
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			hh.AppendUint64(uint64(t[i]))
		}
		limit := sszutils.CalculateLimit(uint64(maxLen), uint64(vlen), uint64(8))
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn10 := func(t []phase0.BLSPubKey) (err error) { // []phase0.BLSPubKey:512:SYNC_COMMITTEE_SIZE:48
		hasLimit, limit, err := ds.ResolveSpecValue("SYNC_COMMITTEE_SIZE")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 512
		}
		idx := hh.Index()
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrVectorLength
		}
		for i := 0; i < vlen; i++ {
			hh.PutBytes(t[i][:])
		}
		for i := vlen; i < int(limit); i++ {
			hh.PutUint8(0)
		}
		hh.Merkleize(idx)
		return err
	}
	fn11 := func(t *altair.SyncCommittee) (err error) { // *altair.SyncCommittee
		idx := hh.Index()
		// Field #0 'Pubkeys'
		if err = fn10(t.Pubkeys); err != nil {
			return err
		}
		// Field #1 'AggregatePubkey'
		hh.PutBytes(t.AggregatePubkey[:])
		hh.Merkleize(idx)
		return err
	}
	fn12 := func(t *ExecutionPayloadHeader) (err error) { // *deneb.ExecutionPayloadHeader
		var root [32]byte
		if root, err = t.HashTreeRoot(); err == nil {
			hh.Append(root[:])
		}
		return err
	}
	fn13 := func(t []*capella.HistoricalSummary) (err error) { // []*capella.HistoricalSummary:16777216:HISTORICAL_ROOTS_LIMIT
		hasLimit, maxLen, err := ds.ResolveSpecValue("HISTORICAL_ROOTS_LIMIT")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 16777216
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			if err = t[i].HashTreeRootWith(hh); err != nil {
				return err
			}
		}
		limit := uint64(maxLen)
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn14 := func(t *BeaconState) (err error) { // *deneb.BeaconState
		idx := hh.Index()
		// Field #0 'GenesisTime'
		hh.PutUint64(uint64(t.GenesisTime))
		// Field #1 'GenesisValidatorsRoot'
		hh.PutBytes(t.GenesisValidatorsRoot[:])
		// Field #2 'Slot'
		hh.PutUint64(uint64(t.Slot))
		// Field #3 'Fork'
		if err = t.Fork.HashTreeRootWith(hh); err != nil {
			return err
		}
		// Field #4 'LatestBlockHeader'
		if err = t.LatestBlockHeader.HashTreeRootWith(hh); err != nil {
			return err
		}
		// Field #5 'BlockRoots'
		if err = fn1(t.BlockRoots); err != nil {
			return err
		}
		// Field #6 'StateRoots'
		if err = fn1(t.StateRoots); err != nil {
			return err
		}
		// Field #7 'HistoricalRoots'
		if err = fn2(t.HistoricalRoots); err != nil {
			return err
		}
		// Field #8 'ETH1Data'
		if err = t.ETH1Data.HashTreeRootWith(hh); err != nil {
			return err
		}
		// Field #9 'ETH1DataVotes'
		if err = fn3(t.ETH1DataVotes); err != nil {
			return err
		}
		// Field #10 'ETH1DepositIndex'
		hh.PutUint64(uint64(t.ETH1DepositIndex))
		// Field #11 'Validators'
		if err = fn4(t.Validators); err != nil {
			return err
		}
		// Field #12 'Balances'
		if err = fn5(t.Balances); err != nil {
			return err
		}
		// Field #13 'RANDAOMixes'
		if err = fn6(t.RANDAOMixes); err != nil {
			return err
		}
		// Field #14 'Slashings'
		if err = fn7(t.Slashings); err != nil {
			return err
		}
		// Field #15 'PreviousEpochParticipation'
		if err = fn8(t.PreviousEpochParticipation); err != nil {
			return err
		}
		// Field #16 'CurrentEpochParticipation'
		if err = fn8(t.CurrentEpochParticipation); err != nil {
			return err
		}
		// Field #17 'JustificationBits'
		hh.PutBytes(t.JustificationBits[:])
		// Field #18 'PreviousJustifiedCheckpoint'
		if err = t.PreviousJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
			return err
		}
		// Field #19 'CurrentJustifiedCheckpoint'
		if err = t.CurrentJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
			return err
		}
		// Field #20 'FinalizedCheckpoint'
		if err = t.FinalizedCheckpoint.HashTreeRootWith(hh); err != nil {
			return err
		}
		// Field #21 'InactivityScores'
		if err = fn9(t.InactivityScores); err != nil {
			return err
		}
		// Field #22 'CurrentSyncCommittee'
		if err = fn11(t.CurrentSyncCommittee); err != nil {
			return err
		}
		// Field #23 'NextSyncCommittee'
		if err = fn11(t.NextSyncCommittee); err != nil {
			return err
		}
		// Field #24 'LatestExecutionPayloadHeader'
		if err = fn12(t.LatestExecutionPayloadHeader); err != nil {
			return err
		}
		// Field #25 'NextWithdrawalIndex'
		hh.PutUint64(uint64(t.NextWithdrawalIndex))
		// Field #26 'NextWithdrawalValidatorIndex'
		hh.PutUint64(uint64(t.NextWithdrawalValidatorIndex))
		// Field #27 'HistoricalSummaries'
		if err = fn13(t.HistoricalSummaries); err != nil {
			return err
		}
		hh.Merkleize(idx)
		return err
	}
	return fn14(t)
}
func (t *BeaconState) HashTreeRootDyn(ds sszutils.DynamicSpecs) ([32]byte, error) {
	pool := &hasher.FastHasherPool
	hh := pool.Get()
	defer func() {
		pool.Put(hh)
	}()
	if err := t.HashTreeRootWithDyn(ds, hh); err != nil {
		return [32]byte{}, err
	}
	r, _ := hh.HashRoot()
	return r, nil
}
func (t *BeaconState) HashTreeRootWith(hh sszutils.HashWalker) error {
	return t.HashTreeRootWithDyn(dynssz.GetGlobalDynSsz(), hh)
}
func (t *BeaconState) HashTreeRoot() ([32]byte, error) {
	pool := &hasher.FastHasherPool
	hh := pool.Get()
	defer func() {
		pool.Put(hh)
	}()
	if err := t.HashTreeRootWithDyn(dynssz.GetGlobalDynSsz(), hh); err != nil {
		return [32]byte{}, err
	}
	r, _ := hh.HashRoot()
	return r, nil
}
