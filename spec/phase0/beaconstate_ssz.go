// Code generated by dynamic-ssz. DO NOT EDIT.
// Hash: 65885ad8ef63644fadc6cb51a5b7f2d834add3ff98105b6f91438ed57bcf0251
// Version: v0.0.4 (https://github.com/pk910/dynamic-ssz)
package phase0

import (
	dynssz "github.com/pk910/dynamic-ssz"
	"github.com/pk910/dynamic-ssz/hasher"
	"github.com/pk910/dynamic-ssz/sszutils"
	go_bitfield "github.com/prysmaticlabs/go-bitfield"
)

var _ = sszutils.ErrListTooBig

func (t *BeaconState) MarshalSSZDyn(ds sszutils.DynamicSpecs, buf []byte) (dst []byte, err error) {
	dst = buf
	fn1 := func(t *Fork) (err error) { // *phase0.Fork
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn2 := func(t *BeaconBlockHeader) (err error) { // *phase0.BeaconBlockHeader
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn3 := func(t []Root) (err error) { // []phase0.Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
		hasLimit, limit, err := ds.ResolveSpecValue("SLOTS_PER_HISTORICAL_ROOT")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 8192
		}
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrListTooBig
		}
		for i := 0; i < vlen; i++ {
			dst = append(dst, t[i][:]...)
		}
		if vlen < int(limit) {
			dst = sszutils.AppendZeroPadding(dst, (int(limit)-vlen)*32)
		}
		return err
	}
	fn4 := func(t []Root) (err error) { // []phase0.Root:32
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			dst = append(dst, t[i][:]...)
		}
		return err
	}
	fn5 := func(t *ETH1Data) (err error) { // *phase0.ETH1Data
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn6 := func(t []*ETH1Data) (err error) { // []*phase0.ETH1Data
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			if err = fn5(t[i]); err != nil {
				return err
			}
		}
		return err
	}
	fn7 := func(t *Validator) (err error) { // *phase0.Validator
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn8 := func(t []*Validator) (err error) { // []*phase0.Validator
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			if err = fn7(t[i]); err != nil {
				return err
			}
		}
		return err
	}
	fn9 := func(t []Gwei) (err error) { // []phase0.Gwei
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			dst = sszutils.MarshalUint64(dst, uint64(t[i]))
		}
		return err
	}
	fn10 := func(t []Root) (err error) { // []phase0.Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
		hasLimit, limit, err := ds.ResolveSpecValue("EPOCHS_PER_HISTORICAL_VECTOR")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 65536
		}
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrListTooBig
		}
		for i := 0; i < vlen; i++ {
			dst = append(dst, t[i][:]...)
		}
		if vlen < int(limit) {
			dst = sszutils.AppendZeroPadding(dst, (int(limit)-vlen)*32)
		}
		return err
	}
	fn11 := func(t []Gwei) (err error) { // []phase0.Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
		hasLimit, limit, err := ds.ResolveSpecValue("EPOCHS_PER_SLASHINGS_VECTOR")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 8192
		}
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrListTooBig
		}
		for i := 0; i < vlen; i++ {
			dst = sszutils.MarshalUint64(dst, uint64(t[i]))
		}
		if vlen < int(limit) {
			dst = sszutils.AppendZeroPadding(dst, (int(limit)-vlen)*8)
		}
		return err
	}
	fn12 := func(t *PendingAttestation) (err error) { // *phase0.PendingAttestation
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn13 := func(t []*PendingAttestation) (err error) { // []*phase0.PendingAttestation
		vlen := len(t)
		dstlen := len(dst)
		dst = sszutils.AppendZeroPadding(dst, vlen*4)
		for i := 0; i < vlen; i++ {
			sszutils.UpdateOffset(dst[dstlen+(i*4):dstlen+((i+1)*4)], len(dst)-dstlen)
			if err = fn12(t[i]); err != nil {
				return err
			}
		}
		return err
	}
	fn14 := func(t *Checkpoint) (err error) { // *phase0.Checkpoint
		dst, err = t.MarshalSSZTo(dst)
		return err
	}
	fn15 := func(t *BeaconState) (err error) { // *phase0.BeaconState
		dstlen := len(dst)
		// Field #0 'GenesisTime'
		dst = sszutils.MarshalUint64(dst, uint64(t.GenesisTime))
		// Field #1 'GenesisValidatorsRoot'
		dst = append(dst, t.GenesisValidatorsRoot[:]...)
		// Field #2 'Slot'
		dst = sszutils.MarshalUint64(dst, uint64(t.Slot))
		// Field #3 'Fork'
		if err = fn1(t.Fork); err != nil {
			return err
		}
		// Field #4 'LatestBlockHeader'
		if err = fn2(t.LatestBlockHeader); err != nil {
			return err
		}
		// Field #5 'BlockRoots'
		if err = fn3(t.BlockRoots); err != nil {
			return err
		}
		// Field #6 'StateRoots'
		if err = fn3(t.StateRoots); err != nil {
			return err
		}
		// Offset #7 'HistoricalRoots'
		offset7 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Field #8 'ETH1Data'
		if err = fn5(t.ETH1Data); err != nil {
			return err
		}
		// Offset #9 'ETH1DataVotes'
		offset9 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Field #10 'ETH1DepositIndex'
		dst = sszutils.MarshalUint64(dst, uint64(t.ETH1DepositIndex))
		// Offset #11 'Validators'
		offset11 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Offset #12 'Balances'
		offset12 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Field #13 'RANDAOMixes'
		if err = fn10(t.RANDAOMixes); err != nil {
			return err
		}
		// Field #14 'Slashings'
		if err = fn11(t.Slashings); err != nil {
			return err
		}
		// Offset #15 'PreviousEpochAttestations'
		offset15 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Offset #16 'CurrentEpochAttestations'
		offset16 := len(dst)
		dst = sszutils.MarshalOffset(dst, 0)
		// Field #17 'JustificationBits'
		if len(t.JustificationBits) > 1 {
			dst = append(dst, t.JustificationBits[:1]...)
		} else {
			dst = append(dst, t.JustificationBits[:]...)
			if len(t.JustificationBits) < 1 {
				dst = sszutils.AppendZeroPadding(dst, 1-len(t.JustificationBits))
			}
		}
		// Field #18 'PreviousJustifiedCheckpoint'
		if err = fn14(t.PreviousJustifiedCheckpoint); err != nil {
			return err
		}
		// Field #19 'CurrentJustifiedCheckpoint'
		if err = fn14(t.CurrentJustifiedCheckpoint); err != nil {
			return err
		}
		// Field #20 'FinalizedCheckpoint'
		if err = fn14(t.FinalizedCheckpoint); err != nil {
			return err
		}
		// Dynamic Field #7 'HistoricalRoots'
		sszutils.UpdateOffset(dst[offset7:offset7+4], len(dst)-dstlen)
		if err = fn4(t.HistoricalRoots); err != nil {
			return err
		}
		// Dynamic Field #9 'ETH1DataVotes'
		sszutils.UpdateOffset(dst[offset9:offset9+4], len(dst)-dstlen)
		if err = fn6(t.ETH1DataVotes); err != nil {
			return err
		}
		// Dynamic Field #11 'Validators'
		sszutils.UpdateOffset(dst[offset11:offset11+4], len(dst)-dstlen)
		if err = fn8(t.Validators); err != nil {
			return err
		}
		// Dynamic Field #12 'Balances'
		sszutils.UpdateOffset(dst[offset12:offset12+4], len(dst)-dstlen)
		if err = fn9(t.Balances); err != nil {
			return err
		}
		// Dynamic Field #15 'PreviousEpochAttestations'
		sszutils.UpdateOffset(dst[offset15:offset15+4], len(dst)-dstlen)
		if err = fn13(t.PreviousEpochAttestations); err != nil {
			return err
		}
		// Dynamic Field #16 'CurrentEpochAttestations'
		sszutils.UpdateOffset(dst[offset16:offset16+4], len(dst)-dstlen)
		if err = fn13(t.CurrentEpochAttestations); err != nil {
			return err
		}
		return err
	}
	err = fn15(t)
	return dst, err
}
func (t *BeaconState) MarshalSSZ() ([]byte, error) {
	return dynssz.GetGlobalDynSsz().MarshalSSZ(t)
}
func (t *BeaconState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	return t.MarshalSSZDyn(dynssz.GetGlobalDynSsz(), buf)
}

func (t *BeaconState) SizeSSZDyn(ds sszutils.DynamicSpecs) (size int) {
	sfn1 := func(t []Root) (size int) { // []Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
		hasLimit, limit, _ := ds.ResolveSpecValue("SLOTS_PER_HISTORICAL_ROOT")
		if !hasLimit {
			limit = 8192
		}
		size += int(limit) * 32
		return size
	}
	sfn2 := func(t []Root) (size int) { // []Root:32
		size += len(t) * 32
		return size
	}
	sfn3 := func(t []*ETH1Data) (size int) { // []*ETH1Data
		size += len(t) * 72
		return size
	}
	sfn4 := func(t []*Validator) (size int) { // []*Validator
		size += len(t) * 121
		return size
	}
	sfn5 := func(t []Gwei) (size int) { // []Gwei
		size += len(t) * 8
		return size
	}
	sfn6 := func(t []Root) (size int) { // []Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
		hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_HISTORICAL_VECTOR")
		if !hasLimit {
			limit = 65536
		}
		size += int(limit) * 32
		return size
	}
	sfn7 := func(t []Gwei) (size int) { // []Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
		hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_SLASHINGS_VECTOR")
		if !hasLimit {
			limit = 8192
		}
		size += int(limit) * 8
		return size
	}
	sfn8 := func(t *PendingAttestation) (size int) { // *PendingAttestation
		size = t.SizeSSZ()
		return size
	}
	sfn9 := func(t []*PendingAttestation) (size int) { // []*PendingAttestation
		vlen := len(t)
		for i := 0; i < vlen; i++ {
			size += 4 + sfn8(t[i])
		}
		return size
	}
	sfn10 := func(t *BeaconState) (size int) { // *BeaconState
		size = 377
		size += sfn1(t.BlockRoots)
		size += sfn1(t.StateRoots)
		size += 4 + sfn2(t.HistoricalRoots)
		size += 4 + sfn3(t.ETH1DataVotes)
		size += 4 + sfn4(t.Validators)
		size += 4 + sfn5(t.Balances)
		size += sfn6(t.RANDAOMixes)
		size += sfn7(t.Slashings)
		size += 4 + sfn9(t.PreviousEpochAttestations)
		size += 4 + sfn9(t.CurrentEpochAttestations)
		return size
	}
	return sfn10(t)
}
func (t *BeaconState) SizeSSZ() (size int) {
	return t.SizeSSZDyn(dynssz.GetGlobalDynSsz())
}

func (t *BeaconState) UnmarshalSSZDyn(ds sszutils.DynamicSpecs, buf []byte) (err error) {
	sfn1 := func() (size int) { // []Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
		hasLimit, limit, _ := ds.ResolveSpecValue("SLOTS_PER_HISTORICAL_ROOT")
		if !hasLimit {
			limit = 8192
		}
		size += int(limit) * 32
		return size
	}()
	sfn2 := func() (size int) { // []Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
		hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_HISTORICAL_VECTOR")
		if !hasLimit {
			limit = 65536
		}
		size += int(limit) * 32
		return size
	}()
	sfn3 := func() (size int) { // []Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
		hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_SLASHINGS_VECTOR")
		if !hasLimit {
			limit = 8192
		}
		size += int(limit) * 8
		return size
	}()
	fn1 := func(t *Fork, buf []byte) (*Fork, error) { // *Fork
		var err error
		if t == nil {
			t = new(Fork)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn2 := func(t *BeaconBlockHeader, buf []byte) (*BeaconBlockHeader, error) { // *BeaconBlockHeader
		var err error
		if t == nil {
			t = new(BeaconBlockHeader)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn3 := func(t []Root, buf []byte) ([]Root, error) { // []Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
		var err error
		itemsize := 32
		limit := sfn1 / itemsize
		if len(t) < int(limit) {
			t = make([]Root, int(limit))
		} else {
			t = t[:int(limit)]
		}
		if len(buf) > int(limit)*itemsize {
			return t, sszutils.ErrListTooBig
		}
		for i := 0; i < int(limit); i++ {
			copy(t[i][:], buf[i*itemsize:(i+1)*itemsize])
		}
		return t, err
	}
	fn4 := func(t []Root, buf []byte) ([]Root, error) { // []Root:32
		var err error
		buflen := len(buf)
		itemsize := 32
		itemCount := buflen / itemsize
		if buflen%itemsize != 0 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]Root, itemCount)
		} else {
			t = t[:itemCount]
		}
		for i := 0; i < itemCount; i++ {
			copy(t[i][:], buf[i*itemsize:(i+1)*itemsize])
		}
		return t, err
	}
	fn5 := func(t *ETH1Data, buf []byte) (*ETH1Data, error) { // *ETH1Data
		var err error
		if t == nil {
			t = new(ETH1Data)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn6 := func(t []*ETH1Data, buf []byte) ([]*ETH1Data, error) { // []*ETH1Data
		var err error
		buflen := len(buf)
		itemsize := 72
		itemCount := buflen / itemsize
		if buflen%itemsize != 0 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]*ETH1Data, itemCount)
		} else {
			t = t[:itemCount]
		}
		for i := 0; i < itemCount; i++ {
			if t[i], err = fn5(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
				return t, err
			}
		}
		return t, err
	}
	fn7 := func(t *Validator, buf []byte) (*Validator, error) { // *Validator
		var err error
		if t == nil {
			t = new(Validator)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn8 := func(t []*Validator, buf []byte) ([]*Validator, error) { // []*Validator
		var err error
		buflen := len(buf)
		itemsize := 121
		itemCount := buflen / itemsize
		if buflen%itemsize != 0 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]*Validator, itemCount)
		} else {
			t = t[:itemCount]
		}
		for i := 0; i < itemCount; i++ {
			if t[i], err = fn7(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
				return t, err
			}
		}
		return t, err
	}
	fn9 := func(t []Gwei, buf []byte) ([]Gwei, error) { // []Gwei
		var err error
		buflen := len(buf)
		itemsize := 8
		itemCount := buflen / itemsize
		if buflen%itemsize != 0 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]Gwei, itemCount)
		} else {
			t = t[:itemCount]
		}
		for i := 0; i < itemCount; i++ {
			t[i] = (Gwei)(sszutils.UnmarshallUint64(buf[i*itemsize : (i+1)*itemsize]))
		}
		return t, err
	}
	fn10 := func(t []Root, buf []byte) ([]Root, error) { // []Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
		var err error
		itemsize := 32
		limit := sfn2 / itemsize
		if len(t) < int(limit) {
			t = make([]Root, int(limit))
		} else {
			t = t[:int(limit)]
		}
		if len(buf) > int(limit)*itemsize {
			return t, sszutils.ErrListTooBig
		}
		for i := 0; i < int(limit); i++ {
			copy(t[i][:], buf[i*itemsize:(i+1)*itemsize])
		}
		return t, err
	}
	fn11 := func(t []Gwei, buf []byte) ([]Gwei, error) { // []Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
		var err error
		itemsize := 8
		limit := sfn3 / itemsize
		if len(t) < int(limit) {
			t = make([]Gwei, int(limit))
		} else {
			t = t[:int(limit)]
		}
		if len(buf) > int(limit)*itemsize {
			return t, sszutils.ErrListTooBig
		}
		for i := 0; i < int(limit); i++ {
			t[i] = (Gwei)(sszutils.UnmarshallUint64(buf[i*itemsize : (i+1)*itemsize]))
		}
		return t, err
	}
	fn12 := func(t *PendingAttestation, buf []byte) (*PendingAttestation, error) { // *PendingAttestation
		var err error
		if t == nil {
			t = new(PendingAttestation)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn13 := func(t []*PendingAttestation, buf []byte) ([]*PendingAttestation, error) { // []*PendingAttestation
		var err error
		buflen := len(buf)
		if buflen == 0 {
			return t, nil
		}
		if buflen < 4 {
			return t, sszutils.ErrUnexpectedEOF
		}
		offset := int(sszutils.ReadOffset(buf[0:4]))
		itemCount := offset / 4
		if buflen < itemCount*4 {
			return t, sszutils.ErrUnexpectedEOF
		}
		if len(t) < itemCount {
			t = make([]*PendingAttestation, itemCount)
		} else {
			t = t[:itemCount]
		}
		var endOffset int
		for i := 0; i < itemCount; i++ {
			if i < itemCount-1 {
				endOffset = int(sszutils.ReadOffset(buf[(i+1)*4 : (i+2)*4]))
			} else {
				endOffset = buflen
			}
			if endOffset < offset || endOffset > buflen {
				return t, sszutils.ErrOffset
			}
			if t[i], err = fn12(t[i], buf[offset:endOffset]); err != nil {
				return t, err
			}
			offset = endOffset
		}
		return t, err
	}
	fn14 := func(t *Checkpoint, buf []byte) (*Checkpoint, error) { // *Checkpoint
		var err error
		if t == nil {
			t = new(Checkpoint)
		}
		err = t.UnmarshalSSZ(buf)
		return t, err
	}
	fn15 := func(t *BeaconState, buf []byte) (*BeaconState, error) { // *BeaconState
		var err error
		if t == nil {
			t = new(BeaconState)
		}
		bufpos := 0
		buflen := len(buf)
		minsize := 401
		if buflen < minsize {
			return t, sszutils.ErrUnexpectedEOF
		}
		// Field #0 'GenesisTime'
		{
			fieldsize := 8
			t.GenesisTime = (uint64)(sszutils.UnmarshallUint64(buf[bufpos : bufpos+fieldsize]))
			bufpos += fieldsize
		}
		// Field #1 'GenesisValidatorsRoot'
		{
			fieldsize := 32
			copy(t.GenesisValidatorsRoot[:], buf[bufpos:bufpos+fieldsize])
			bufpos += fieldsize
		}
		// Field #2 'Slot'
		{
			fieldsize := 8
			t.Slot = (Slot)(sszutils.UnmarshallUint64(buf[bufpos : bufpos+fieldsize]))
			bufpos += fieldsize
		}
		// Field #3 'Fork'
		{
			fieldsize := 16
			if t.Fork, err = fn1(t.Fork, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #4 'LatestBlockHeader'
		{
			fieldsize := 112
			if t.LatestBlockHeader, err = fn2(t.LatestBlockHeader, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #5 'BlockRoots'
		{
			fieldsize := sfn1
			minsize += fieldsize
			if buflen < minsize {
				return t, sszutils.ErrUnexpectedEOF
			}
			if t.BlockRoots, err = fn3(t.BlockRoots, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #6 'StateRoots'
		{
			fieldsize := sfn1
			minsize += fieldsize
			if buflen < minsize {
				return t, sszutils.ErrUnexpectedEOF
			}
			if t.StateRoots, err = fn3(t.StateRoots, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Offset #7 'HistoricalRoots'
		offset7 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Field #8 'ETH1Data'
		{
			fieldsize := 72
			if t.ETH1Data, err = fn5(t.ETH1Data, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Offset #9 'ETH1DataVotes'
		offset9 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Field #10 'ETH1DepositIndex'
		{
			fieldsize := 8
			t.ETH1DepositIndex = (uint64)(sszutils.UnmarshallUint64(buf[bufpos : bufpos+fieldsize]))
			bufpos += fieldsize
		}
		// Offset #11 'Validators'
		offset11 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Offset #12 'Balances'
		offset12 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Field #13 'RANDAOMixes'
		{
			fieldsize := sfn2
			minsize += fieldsize
			if buflen < minsize {
				return t, sszutils.ErrUnexpectedEOF
			}
			if t.RANDAOMixes, err = fn10(t.RANDAOMixes, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #14 'Slashings'
		{
			fieldsize := sfn3
			minsize += fieldsize
			if buflen < minsize {
				return t, sszutils.ErrUnexpectedEOF
			}
			if t.Slashings, err = fn11(t.Slashings, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Offset #15 'PreviousEpochAttestations'
		offset15 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Offset #16 'CurrentEpochAttestations'
		offset16 := int(sszutils.ReadOffset(buf[bufpos : bufpos+4]))
		bufpos += 4
		// Field #17 'JustificationBits'
		{
			fieldsize := 1
			if len(t.JustificationBits) < len(buf[bufpos:bufpos+fieldsize]) {
				t.JustificationBits = make(go_bitfield.Bitvector4, len(buf[bufpos:bufpos+fieldsize]))
			} else {
				t.JustificationBits = t.JustificationBits[:len(buf[bufpos:bufpos+fieldsize])]
			}
			copy(t.JustificationBits[:], buf[bufpos:bufpos+fieldsize])
			bufpos += fieldsize
		}
		// Field #18 'PreviousJustifiedCheckpoint'
		{
			fieldsize := 40
			if t.PreviousJustifiedCheckpoint, err = fn14(t.PreviousJustifiedCheckpoint, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #19 'CurrentJustifiedCheckpoint'
		{
			fieldsize := 40
			if t.CurrentJustifiedCheckpoint, err = fn14(t.CurrentJustifiedCheckpoint, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Field #20 'FinalizedCheckpoint'
		{
			fieldsize := 40
			if t.FinalizedCheckpoint, err = fn14(t.FinalizedCheckpoint, buf[bufpos:bufpos+fieldsize]); err != nil {
				return t, err
			}
			bufpos += fieldsize
		}
		// Dynamic Field #7 'HistoricalRoots'
		if offset7 < bufpos || offset9 > buflen || offset9 < offset7 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset7:offset9]
			if t.HistoricalRoots, err = fn4(t.HistoricalRoots, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #9 'ETH1DataVotes'
		if offset9 < bufpos || offset11 > buflen || offset11 < offset9 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset9:offset11]
			if t.ETH1DataVotes, err = fn6(t.ETH1DataVotes, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #11 'Validators'
		if offset11 < bufpos || offset12 > buflen || offset12 < offset11 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset11:offset12]
			if t.Validators, err = fn8(t.Validators, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #12 'Balances'
		if offset12 < bufpos || offset15 > buflen || offset15 < offset12 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset12:offset15]
			if t.Balances, err = fn9(t.Balances, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #15 'PreviousEpochAttestations'
		if offset15 < bufpos || offset16 > buflen || offset16 < offset15 {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset15:offset16]
			if t.PreviousEpochAttestations, err = fn13(t.PreviousEpochAttestations, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		// Dynamic Field #16 'CurrentEpochAttestations'
		if offset16 < bufpos {
			return t, sszutils.ErrOffset
		}
		{
			fieldSlice := buf[offset16:]
			if t.CurrentEpochAttestations, err = fn13(t.CurrentEpochAttestations, fieldSlice); err != nil {
				return t, err
			}
			bufpos += len(fieldSlice)
		}
		return t, err
	}
	_, err = fn15(t, buf)
	return err
}
func (t *BeaconState) UnmarshalSSZ(buf []byte) (err error) {
	return t.UnmarshalSSZDyn(dynssz.GetGlobalDynSsz(), buf)
}

func (t *BeaconState) HashTreeRootWithDyn(ds sszutils.DynamicSpecs, hh sszutils.HashWalker) error {
	fn1 := func(t []Root) (err error) { // []phase0.Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
		hasLimit, limit, err := ds.ResolveSpecValue("SLOTS_PER_HISTORICAL_ROOT")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 8192
		}
		idx := hh.Index()
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrVectorLength
		}
		for i := 0; i < vlen; i++ {
			hh.PutBytes(t[i][:])
		}
		for i := vlen; i < int(limit); i++ {
			hh.PutUint8(0)
		}
		hh.Merkleize(idx)
		return err
	}
	fn2 := func(t []Root) (err error) { // []phase0.Root:16777216:HISTORICAL_ROOTS_LIMIT:32
		hasLimit, maxLen, err := ds.ResolveSpecValue("HISTORICAL_ROOTS_LIMIT")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 16777216
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			hh.PutBytes(t[i][:])
		}
		limit := uint64(maxLen)
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn3 := func(t []*ETH1Data) (err error) { // []*phase0.ETH1Data:2048:EPOCHS_PER_ETH1_VOTING_PERIOD*SLOTS_PER_EPOCH
		hasLimit, maxLen, err := ds.ResolveSpecValue("EPOCHS_PER_ETH1_VOTING_PERIOD*SLOTS_PER_EPOCH")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 2048
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			if err = t[i].HashTreeRootWith(hh); err != nil {
				return err
			}
		}
		limit := uint64(maxLen)
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn4 := func(t []*Validator) (err error) { // []*phase0.Validator:1099511627776:VALIDATOR_REGISTRY_LIMIT
		hasLimit, maxLen, err := ds.ResolveSpecValue("VALIDATOR_REGISTRY_LIMIT")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 1099511627776
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			if err = t[i].HashTreeRootWith(hh); err != nil {
				return err
			}
		}
		limit := uint64(maxLen)
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn5 := func(t []Gwei) (err error) { // []phase0.Gwei:1099511627776:VALIDATOR_REGISTRY_LIMIT
		hasLimit, maxLen, err := ds.ResolveSpecValue("VALIDATOR_REGISTRY_LIMIT")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 1099511627776
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			hh.AppendUint64(uint64(t[i]))
		}
		limit := sszutils.CalculateLimit(uint64(maxLen), uint64(vlen), uint64(8))
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn6 := func(t []Root) (err error) { // []phase0.Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
		hasLimit, limit, err := ds.ResolveSpecValue("EPOCHS_PER_HISTORICAL_VECTOR")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 65536
		}
		idx := hh.Index()
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrVectorLength
		}
		for i := 0; i < vlen; i++ {
			hh.PutBytes(t[i][:])
		}
		for i := vlen; i < int(limit); i++ {
			hh.PutUint8(0)
		}
		hh.Merkleize(idx)
		return err
	}
	fn7 := func(t []Gwei) (err error) { // []phase0.Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
		hasLimit, limit, err := ds.ResolveSpecValue("EPOCHS_PER_SLASHINGS_VECTOR")
		if err != nil {
			return err
		}
		if !hasLimit {
			limit = 8192
		}
		idx := hh.Index()
		vlen := len(t)
		if vlen > int(limit) {
			return sszutils.ErrVectorLength
		}
		for i := 0; i < vlen; i++ {
			hh.AppendUint64(uint64(t[i]))
		}
		for i := vlen; i < int(limit); i++ {
			hh.PutUint8(0)
		}
		hh.Merkleize(idx)
		return err
	}
	fn8 := func(t []*PendingAttestation) (err error) { // []*phase0.PendingAttestation:4096:MAX_ATTESTATIONS*SLOTS_PER_EPOCH
		hasLimit, maxLen, err := ds.ResolveSpecValue("MAX_ATTESTATIONS*SLOTS_PER_EPOCH")
		if err != nil {
			return err
		}
		if !hasLimit {
			maxLen = 4096
		}
		vlen := len(t)
		if vlen > int(maxLen) {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := 0; i < vlen; i++ {
			if err = t[i].HashTreeRootWith(hh); err != nil {
				return err
			}
		}
		limit := uint64(maxLen)
		if (uint64(hh.Index()-idx)+31)/32 > limit {
			return sszutils.ErrListTooBig
		}
		hh.MerkleizeWithMixin(idx, uint64(vlen), limit)
		return err
	}
	fn9 := func(t *BeaconState) (err error) { // *phase0.BeaconState
		idx := hh.Index()
		// Field #0 'GenesisTime'
		hh.PutUint64(uint64(t.GenesisTime))
		// Field #1 'GenesisValidatorsRoot'
		hh.PutBytes(t.GenesisValidatorsRoot[:])
		// Field #2 'Slot'
		hh.PutUint64(uint64(t.Slot))
		// Field #3 'Fork'
		if err = t.Fork.HashTreeRootWith(hh); err != nil {
			return err
		}
		// Field #4 'LatestBlockHeader'
		if err = t.LatestBlockHeader.HashTreeRootWith(hh); err != nil {
			return err
		}
		// Field #5 'BlockRoots'
		if err = fn1(t.BlockRoots); err != nil {
			return err
		}
		// Field #6 'StateRoots'
		if err = fn1(t.StateRoots); err != nil {
			return err
		}
		// Field #7 'HistoricalRoots'
		if err = fn2(t.HistoricalRoots); err != nil {
			return err
		}
		// Field #8 'ETH1Data'
		if err = t.ETH1Data.HashTreeRootWith(hh); err != nil {
			return err
		}
		// Field #9 'ETH1DataVotes'
		if err = fn3(t.ETH1DataVotes); err != nil {
			return err
		}
		// Field #10 'ETH1DepositIndex'
		hh.PutUint64(uint64(t.ETH1DepositIndex))
		// Field #11 'Validators'
		if err = fn4(t.Validators); err != nil {
			return err
		}
		// Field #12 'Balances'
		if err = fn5(t.Balances); err != nil {
			return err
		}
		// Field #13 'RANDAOMixes'
		if err = fn6(t.RANDAOMixes); err != nil {
			return err
		}
		// Field #14 'Slashings'
		if err = fn7(t.Slashings); err != nil {
			return err
		}
		// Field #15 'PreviousEpochAttestations'
		if err = fn8(t.PreviousEpochAttestations); err != nil {
			return err
		}
		// Field #16 'CurrentEpochAttestations'
		if err = fn8(t.CurrentEpochAttestations); err != nil {
			return err
		}
		// Field #17 'JustificationBits'
		hh.PutBytes(t.JustificationBits[:])
		// Field #18 'PreviousJustifiedCheckpoint'
		if err = t.PreviousJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
			return err
		}
		// Field #19 'CurrentJustifiedCheckpoint'
		if err = t.CurrentJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
			return err
		}
		// Field #20 'FinalizedCheckpoint'
		if err = t.FinalizedCheckpoint.HashTreeRootWith(hh); err != nil {
			return err
		}
		hh.Merkleize(idx)
		return err
	}
	return fn9(t)
}
func (t *BeaconState) HashTreeRootDyn(ds sszutils.DynamicSpecs) ([32]byte, error) {
	pool := &hasher.FastHasherPool
	hh := pool.Get()
	defer func() {
		pool.Put(hh)
	}()
	if err := t.HashTreeRootWithDyn(ds, hh); err != nil {
		return [32]byte{}, err
	}
	r, _ := hh.HashRoot()
	return r, nil
}
func (t *BeaconState) HashTreeRootWith(hh sszutils.HashWalker) error {
	return t.HashTreeRootWithDyn(dynssz.GetGlobalDynSsz(), hh)
}
func (t *BeaconState) HashTreeRoot() ([32]byte, error) {
	pool := &hasher.FastHasherPool
	hh := pool.Get()
	defer func() {
		pool.Put(hh)
	}()
	if err := t.HashTreeRootWithDyn(dynssz.GetGlobalDynSsz(), hh); err != nil {
		return [32]byte{}, err
	}
	r, _ := hh.HashRoot()
	return r, nil
}
